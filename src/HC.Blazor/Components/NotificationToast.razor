@inherits HCComponentBase
@implements IAsyncDisposable
@using HC.Notifications
@using Microsoft.AspNetCore.Components
@using Microsoft.Extensions.Logging
@using Microsoft.JSInterop
@using System.Linq

@if (_isInitialized)
{
    <div class="notification-toast-container position-fixed top-0 end-0 p-3">
        @foreach (var notification in _notifications)
        {
            var isRemoving = _removingNotifications.Contains(notification.Id);
            <div class="toast show mb-2 notification-toast-item @(isRemoving ? "fade-out" : "")" 
                 role="alert" 
                 aria-live="assertive" 
                 aria-atomic="true">
                <div class="toast-header @GetPriorityClass(notification.Priority)">
                    <i class="fas fa-bell me-2"></i>
                    <strong class="me-auto">@GetLocalizedTitle(notification)</strong>
                    <small class="text-muted">@notification.CreationTime.ToString("HH:mm")</small>
                    <button type="button" class="btn-close" @onclick="() => RemoveNotificationAsync(notification.Id)" aria-label="Close"></button>
                </div>
                <div class="toast-body">
                    @GetLocalizedContent(notification)
                    @if (!string.IsNullOrEmpty(notification.RelatedId))
                    {
                        <div class="mt-2">
                            <a href="@GetRelatedUrl(notification)" class="btn btn-sm btn-primary">@L["ViewDetail"]</a>
                        </div>
                    }
                </div>
            </div>
        }
    </div>
}

@code {
    private List<NotificationDto> _notifications = new();
    private HashSet<Guid> _removingNotifications = new(); // Track notifications being removed for fade-out animation
    private bool _isInitialized = false;
    private bool _isInitializing = false; // Prevent multiple initialization attempts
    private DotNetObjectReference<NotificationToast>? _objRef;

    [Inject] private NavigationManager NavigationManager { get; set; } = null!;
    [Inject] private INotificationsAppService NotificationsAppService { get; set; } = null!;
    [Inject] private ILogger<NotificationToast> NotificationLogger { get; set; } = null!;
    [Inject] private IJSRuntime JS { get; set; } = null!;

    protected override void OnInitialized()
    {
        base.OnInitialized();
        NotificationLogger.LogInformation("[NotificationToast] ðŸ”µ Component OnInitialized called. IsAuthenticated={IsAuthenticated}, UserId={UserId}", 
            CurrentUser.IsAuthenticated, CurrentUser.Id?.ToString() ?? "null");
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender && CurrentUser.IsAuthenticated && !_isInitialized && !_isInitializing)
        {
            _isInitializing = true;
            NotificationLogger.LogInformation("[NotificationToast] ðŸŸ¢ Component OnAfterRenderAsync (firstRender). IsAuthenticated={IsAuthenticated}, UserId={UserId}", 
                CurrentUser.IsAuthenticated, CurrentUser.Id);
            
            try
            {
                // Create DotNetObjectReference for JavaScript interop
                _objRef = DotNetObjectReference.Create(this);
                
                // Initialize SignalR connection from JavaScript (browser-side)
                // This ensures cookies are sent correctly with the connection
                await JS.InvokeVoidAsync("notificationHub.start", _objRef);
                
                _isInitialized = true;
                NotificationLogger.LogInformation("[NotificationToast] âœ… SignalR connection initialized from JavaScript. IsInitialized={IsInitialized}", _isInitialized);
            }
            catch (Exception ex)
            {
                NotificationLogger.LogError(ex, "[NotificationToast] âŒ Error initializing SignalR connection from JavaScript: Message={Message}", ex.Message);
                _isInitializing = false; // Reset on error so it can retry
            }
        }
    }

    [JSInvokable]
    public async Task OnNotificationReceived(string notificationId)
    {
        try
        {
            NotificationLogger.LogInformation("[NotificationToast] âœ… Received notification from SignalR: NotificationId={NotificationId}", notificationId);
            
            if (Guid.TryParse(notificationId, out var guid))
            {
                await LoadNotificationAsync(guid);
                await InvokeAsync(StateHasChanged);
            }
            else
            {
                NotificationLogger.LogWarning("[NotificationToast] âš ï¸ Invalid notification ID format: NotificationId={NotificationId}", notificationId);
            }
        }
        catch (Exception ex)
        {
            NotificationLogger.LogError(ex, "[NotificationToast] âŒ Error handling notification: NotificationId={NotificationId}, Message={Message}", 
                notificationId, ex.Message);
        }
    }

    private async Task LoadNotificationAsync(Guid notificationId)
    {
        try
        {
            NotificationLogger.LogInformation("[NotificationToast] Loading notification: NotificationId={NotificationId}", notificationId);
            
            // Check if notification already exists to prevent duplicates
            if (_notifications.Any(n => n.Id == notificationId))
            {
                NotificationLogger.LogWarning("[NotificationToast] âš ï¸ Notification already exists, skipping: NotificationId={NotificationId}", notificationId);
                return;
            }
            
            var notification = await NotificationsAppService.GetAsync(notificationId);
            if (notification != null)
            {
                NotificationLogger.LogInformation("[NotificationToast] âœ… Notification loaded: NotificationId={NotificationId}, Title={Title}", 
                    notificationId, notification.Title);
                _notifications.Insert(0, notification);
                
                // Auto-remove after 5 seconds with fade-out animation
                _ = Task.Run(async () =>
                {
                    await Task.Delay(5000);
                    await RemoveNotificationWithAnimationAsync(notificationId);
                });
            }
            else
            {
                NotificationLogger.LogWarning("[NotificationToast] âš ï¸ Notification not found: NotificationId={NotificationId}", notificationId);
            }
        }
        catch (Exception ex)
        {
            NotificationLogger.LogError(ex, "[NotificationToast] âŒ Error loading notification: NotificationId={NotificationId}, Message={Message}", 
                notificationId, ex.Message);
        }
    }

    private async Task RemoveNotificationWithAnimationAsync(Guid notificationId)
    {
        // Add to removing set to trigger fade-out animation
        _removingNotifications.Add(notificationId);
        await InvokeAsync(StateHasChanged);
        
        // Wait for animation to complete (300ms)
        await Task.Delay(300);
        
        // Remove from list
        _notifications.RemoveAll(n => n.Id == notificationId);
        _removingNotifications.Remove(notificationId);
        await InvokeAsync(StateHasChanged);
    }

    private async Task RemoveNotificationAsync(Guid notificationId)
    {
        await RemoveNotificationWithAnimationAsync(notificationId);
    }

    private string GetPriorityClass(string priority)
    {
        return priority?.ToUpper() switch
        {
            "HIGH" => "bg-danger text-white",
            "URGENT" => "bg-danger text-white",
            "NORMAL" => "bg-info text-white",
            "LOW" => "bg-secondary text-white",
            _ => "bg-primary text-white"
        };
    }

    private string GetLocalizedTitle(NotificationDto notification)
    {
        // If Title contains "|", it's a key with parameters, otherwise it's just a key
        if (string.IsNullOrEmpty(notification.Title))
            return string.Empty;
            
        // Check if it's a localization key (doesn't contain "|" or is a simple key)
        // Try to get localized string, if not found, return original
        try
        {
            var localized = L[notification.Title];
            return localized?.Value ?? notification.Title;
        }
        catch (Exception ex)
        {
            NotificationLogger.LogWarning(ex, "[NotificationToast] Failed to localize title: Key={Key}", notification.Title);
            return notification.Title;
        }
    }

    private string GetLocalizedContent(NotificationDto notification)
    {
        // If Content contains "|", it's a key with parameters: "Key|param1|param2|param3"
        if (string.IsNullOrEmpty(notification.Content))
            return string.Empty;
            
        var parts = notification.Content.Split('|');
        if (parts.Length > 1)
        {
            // Has parameters: parts[0] is key, parts[1..] are parameters
            var key = parts[0];
            var parameters = parts.Skip(1).ToArray();
            try
            {
                // Get localized string and format with parameters
                var localizedString = L[key]?.Value;
                if (string.IsNullOrEmpty(localizedString))
                {
                    NotificationLogger.LogWarning("[NotificationToast] Localization key not found: Key={Key}", key);
                    return notification.Content;
                }
                return string.Format(localizedString, parameters);
            }
            catch (Exception ex)
            {
                NotificationLogger.LogWarning(ex, "[NotificationToast] Failed to localize content with parameters: Key={Key}, Parameters={Parameters}", 
                    key, string.Join(", ", parameters));
                return notification.Content;
            }
        }
        else
        {
            // No parameters, just a key
            try
            {
                var localized = L[notification.Content];
                return localized?.Value ?? notification.Content;
            }
            catch (Exception ex)
            {
                NotificationLogger.LogWarning(ex, "[NotificationToast] Failed to localize content: Key={Key}", notification.Content);
                return notification.Content;
            }
        }
    }

    private string GetRelatedUrl(NotificationDto notification)
    {
        if (string.IsNullOrEmpty(notification.RelatedId) || string.IsNullOrEmpty(notification.RelatedType))
            return "#";

        return notification.RelatedType.ToUpper() switch
        {
            "TASK" => $"/project-task-detail/{notification.RelatedId}",
            "PROJECT" => $"/project-detail/{notification.RelatedId}",
            "DOCUMENT" => $"/document-detail/{notification.RelatedId}",
            _ => "#"
        };
    }

    public async ValueTask DisposeAsync()
    {
        try
        {
            // Stop SignalR connection from JavaScript
            if (_isInitialized)
            {
                await JS.InvokeVoidAsync("notificationHub.stop");
                NotificationLogger.LogInformation("[NotificationToast] SignalR connection stopped");
            }
        }
        catch (Exception ex)
        {
            NotificationLogger.LogError(ex, "[NotificationToast] Error stopping SignalR connection: Message={Message}", ex.Message);
        }
        finally
        {
            _objRef?.Dispose();
        }
    }
}



<style>
    .notification-toast-container {
    z-index: 1080;
}

.notification-toast-item {
    min-width: 320px;
    background: #ffffff;
    border-radius: 14px;
    border: 1px solid #eef1f7;
    box-shadow: 0 10px 30px rgba(18, 38, 63, 0.08);
    overflow: hidden;
    animation: fadeIn 0.25s ease-out;
    transition: all 0.25s ease;
}

/* Header */
.notification-toast-item .toast-header {
    border-bottom: none;
    padding: 0.75rem 1rem;
    font-weight: 600;
    font-size: 0.9rem;
    background: linear-gradient(90deg, #5b7cfa, #6f4cf3);
    color: white;
}

/* Body */
.notification-toast-item .toast-body {
    padding: 0.9rem 1rem 1rem 1rem;
    color: #4a5568;
    font-size: 0.85rem;
}

/* Priority variants */
.notification-toast-item .bg-danger {
    background: linear-gradient(90deg, #ff5f7e, #ff3d68) !important;
}

.notification-toast-item .bg-info {
    background: linear-gradient(90deg, #5b7cfa, #6f4cf3) !important;
}

.notification-toast-item .bg-secondary {
    background: linear-gradient(90deg, #94a3b8, #64748b) !important;
}

.notification-toast-item .bg-primary {
    background: linear-gradient(90deg, #5b7cfa, #6f4cf3) !important;
}

/* Close button */
.notification-toast-item .btn-close {
    filter: invert(1);
    opacity: 0.8;
}

.notification-toast-item .btn-close:hover {
    opacity: 1;
}

/* Fade animation */
.notification-toast-item.fade-out {
    opacity: 0;
    transform: translateX(80px);
}

@@keyframes fadeIn {
    from {
        opacity: 0;
        transform: translateX(80px);
    }
    to {
        opacity: 1;
        transform: translateX(0);
    }
}
</style>
